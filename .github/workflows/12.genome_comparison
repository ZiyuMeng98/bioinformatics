# 数据准备
mkdir -p ~/working/12.genome_comparison/a.preparing_data
cd ~/working/12.genome_comparison/a.preparing_data
# ncbi收集数据
# 1. 通过NCBI的Genome数据库(https://www.ncbi.nlm.nih.gov/genome)查找目标物种的信息
# 2. 手工生成文件source.txt，该文件前4列为：物种缩写名（推荐为属名前2个字母+种名前3个字母）、双名法拉丁文物种名、NCBI的Genome数据库网址、从NCBI下载的数据文件前缀。
# 3. 该文件前第一列用于后续的数据文件名前缀、第二列用于后续将结果中的物种名缩写转换成物种名全称、第三列用于数据的批量化下载。此外，手动编辑文件source.txt时，可以生成更多的列，记录其它基因组信息
echo -e "parub\tPaxillus rubicundulus\thttps://www.ncbi.nlm.nih.gov/genome/35925
sccit\tScleroderma citrinum\thttps://www.ncbi.nlm.nih.gov/genome/18213
laame\tLaccaria amethystina\thttps://www.ncbi.nlm.nih.gov/genome/17383
plost\tPleurotus ostreatus\thttps://www.ncbi.nlm.nih.gov/genome/909?genome_assembly_id=202364
lasul\tLaetiporus sulphureus\thttps://www.ncbi.nlm.nih.gov/genome/17416
phgig\tPhlebiopsis gigantea\thttps://www.ncbi.nlm.nih.gov/genome/18214" > source.txt
# 批量化下载数据：基因组序列和基因结构注释文件
while IFS=$'\t' read -r col1 col2 url; do
    if [ -n "$url" ]; then
        prefix=$(curl -s "$url" | grep -o 'href="[^"]*_genomic\.gff\.gz"' | sed 's/href="//;s/_genomic\.gff\.gz"//' | sed 's/.*\///')
        if [ -n "$prefix" ]; then
            echo "wget ${prefix}_genomic.gff.gz -O ${col1}.genomic.gff.gz"
            echo "wget ${prefix}_genomic.fna.gz -O ${col1}.genomic.fna.gz"
        fi
    fi
done < source.txt > command.download.list
ParaFly -c command.download.list -CPU 16
tar -zxf genomics_data_from_NCBI.tar.gz
# 解压并处理所有文件，对NCBI的GFF文件进行格式修正。默认下NCBI的GFF格式不太正确，且其基因ID编号比较乱
# 对NCBI的GFF3文件进行整理，仅保留含有mRNA信息的基因，修正尾部的CDS（有些NCBI的注释结果中最后一个CDS是不包含终止密码子的，修正同一条链上存在重叠的基因情况，并对基因id进行重命名
# 最后，得到所有基因的Protein和CDS序列。若一个基因存在多个可变剪接，则仅保留CDS最长的转录本信息
for FNA in *.genomic.fna.gz;do
    i="${FNA%%.genomic.fna.gz}"
    gff_file="${i}.genomic.gff.gz"
    if [[ -f "$gff_file" ]]; then
       echo "processing: $i"
       gzip -dc $i.genomic.gff.gz > $i.genome.gff
       gzip -dc $i.genomic.fna.gz > $i.genome.fasta
       echo "finish: ${i}.fna.gz"
       /opt/biosoft/geta/bin/GFF3Clear --coverage 0.3  --gene_code_length 5 --gene_prefix $i --genome $i.genome.fasta $i.genome.gff > $i.geneModels.gff3 2> $i.GFF3Clear.log
       /opt/biosoft/geta/bin/gff3ToGtf.pl $i.genome.fasta $i.geneModels.gff3 > $i.geneModels.gtf 2> $i.gff3ToGtf.log
       /opt/biosoft/geta/bin/eukaryotic_gene_model_statistics.pl $i.geneModels.gtf $i.genome.fasta $i > $i.statistics
       echo "done: $i"
    else
       echo "warning: GFF file for $i not found, skipping..." >&2
    fi
done



# OrthoFinder同源基因聚类分析
mkdir -p ~/working/12.genome_comparison/b.OrthoFinder
cd ~/working/12.genome_comparison/b.OrthoFinder
mkdir -p compliantFasta
cd compliantFasta
for A in ../a.preparing_data/*.protein.fasta; do
    i="$(basename "$A" .protein.fasta)"
    echo "processing protein: $i"
    sed "s/>/>${i}|/" ../a.preparing_data/${i}.protein.fasta > compliantProtein/${i}.fasta
    echo "processing CDS: $i"
    sed "s/>/>${i}|/" ../a.preparing_data/${i}.CDS.fasta > compliantCDS/${i}.fasta
done
# 默认设置下输出文件夹在输入文件夹里面，使用-o参数设置输出文件夹路径。使用-op参数设置运行diamond前终止，以手动运行diamond并设置更严格的BLASTP阈值。
orthofinder -f compliantFasta -o OrthoFinder -op > command.diamond.list
# 修改diamond参数，手动BLASTP分析并过滤比对结果
awk '/diamond blastp/ { gsub(/--compress 1/, ""); gsub(/\.txt/, ".xml"); gsub(/ -e [^ ]*/, " --evalue 1e-5"); gsub(/ -p 1 /, " -p 4 "); print $0 " --outfmt 5 --max-target-seqs 500 --id 10"; next } {next}' command.diamond.list > tmp && mv tmp command.diamond.list
grep -o '[^ ]*\.xml' command.diamond.list | while read xml_file; do
    base="${xml_file%.xml}"
    echo "parsing_blast_result.pl --no-header --max-hit-num 500 --evalue 1e-9 --CIP 0.3 --query-coverage 0.5 --db-query 0.5 $xml_file | gzip -c - > $base.txt.gz"
done > command.parsing_blast_result.list
ParaFly -c command.parsing_blast_result.list -CPU 8
# 继续运行OrthoFinder命令进行直系同源基因分析
OrthoFinderWorkingDir=$(head -n 1 command.diamond.list | grep -o -- '-d [^ ]*/' | sed 's/-d //;s|/$||')
/opt/biosoft/OrthoFinder/orthofinder -b $OrthoFinderWorkingDir -og
# 得到直系同源基因聚类结果groups.txt
python3 orthomcl_mcl2Groups.py OrthoFinder/*/WorkingDirectory/OrthoFinder/*/Orthogroups/Orthogroups.txt
ln -sf groups.OG.txt groups.txt
# 进行同源基因数量的统计
cat groups.OG.txt groups.PG.txt groups.filtered.txt > groups.All.txt
python3 orthomcl_genes_number_stats.py groups.All.txt compliantProtein > genes_number_stats.txt


# c. 使用单拷贝同源基因构建物种树
mkdir -p ~/working/12.genome_comparison/c.species_tree
cd ~/working/12.genome_comparison/c.species_tree
python3 orthomcl_extract_ortholog_seqs.py  --out_directory orthologGroups_CDS --species_ratio 1 --single_copy_species_ratio 0.5 --copy_num 10 --max_seq_length 6000 ../b.OrthoFinder/groups.txt ../b.OrthoFinder/compliantCDS/
python3 orthomcl_extract_ortholog_seqs.py --out_directory orthologGroups_Protein --species_ratio 1 --single_copy_species_ratio 0.5 --copy_num 10 --max_seq_length 6000 --compliantFasta_dir_for_calculating_seq_length  ../b.OrthoFinder/compliantCDS ../b.OrthoFinder/groups.txt ../b.OrthoFinder/compliantProtein
sed -i 's/\*$//; s/\*/X/g' orthologGroups_Protein/*.fasta
basename -a -s .fasta orthologGroups_Protein/*.fasta > orthologGroups.txt
# 对单拷贝同源进行进行多序列比对
for i in `cat orthologGroups.txt`; do
   echo "/opt/biosoft/mafft/bin/linsi orthologGroups_Protein/$i.fasta > orthologGroups_Protein/$i.fasta.align"  
done > command.linsi.list
ParaFly -c command.linsi.list -CPU 8
# 将Protein序列比对结果转换为Codon序列比对结果
for i in `cat orthologGroups.txt`; do
    echo "python3 protein_alignment_cds_alignemnt.py orthologGroups_Protein/$i.fasta.align orthologGroups_CDS/$i.fasta > orthologGroups_CDS/$i.fasta.align"  
done > command.protein_alignment_cds_alignemnt.list
ParaFly -c command.protein_alignment_cds_alignemnt.list -CPU 8  ls orthologGroups_CDS/*.fasta.align| wc -l
###如果失败则使用 sh command.protein_alignment_cds_alignemnt.list
# 对Codon序列比对结果进行保守区块提取
while IFS= read -r i; do
    i=$(echo "$i" | xargs)
    echo "/opt/biosoft/Gblocks_0.91b/Gblocks orthologGroups_CDS/$i.fasta.align -t=c && { [ -f orthologGroups_CDS/$i.fasta.align-gb ] && echo '$i CDS completed' || echo '$i CDS failed' >&2; } || echo '$i CDS skipped' >&2"
    echo "/opt/biosoft/Gblocks_0.91b/Gblocks orthologGroups_Protein/$i.fasta.align -t=p && { [ -f orthologGroups_Protein/$i.fasta.align-gb ] && echo '$i Protein completed' || echo '$i Protein failed' >&2; } || echo '$i Protein skipped' >&2"
done < orthologGroups.txt > command.Gblocks.list
ParaFly -c command.Gblocks.list -CPU 8
# 将各个同源基因家族的多序列比对结果转换为Phylip格式
for i in $(cat orthologGroups.txt); do
    sed 's/^\(>[^[:space:]]*\).*/\1/; s/ //g' "orthologGroups_CDS/$i.fasta.align-gb" > "orthologGroups_CDS/$i.fasta.align-gb.fasta"
done
for i in `cat orthologGroups.txt`; do
    echo "/opt/biosoft/RAxML-8.2.12/usefulScripts/convertFasta2Phylip.sh orthologGroups_CDS/$i.fasta.align-gb.fasta > orthologGroups_CDS/$i.phy"
done > command.convert_fasta_phylip.list
ParaFly -c command.convert_fasta_phylip.list -CPU 8
# 整合所有单拷贝同源基因的Codon序列比对结果，并使用ML算法构建物系统发育树
python3 get_all_codon_alignments.py orthologGroups_CDS/*.align-gb > allSingleCopyOrthologsAlign.Codon.fasta
mkdir FastTree
cd FastTree
mafft --auto --thread 16 ../allSingleCopyOrthologsAlign.Codon.fasta > aligned.fasta  #thread在服务器能承受的范围越大越好
FastTree -nt -gtr -gamma aligned.fasta > tree_abbr.FastTree
cp tree_abbr.FastTree tree_fullName.FastTree
cut -f 1,2 ../../a.preparing_data/source.txt | while read abbr full; do
    sed -i "s/$abbr/$full/g" tree_fullName.FastTree
done
cp tree* ../
cd ..

mkdir iqtree
cd iqtree
/opt/biosoft/iqtree/iqtree-2.2.0-Linux/bin/iqtree2 -s ../FastTree/aligned.fasta -m GTR+G -bb 1000 -nt 64 -mem 300G
# 复制带bootstrap支持率的共识树
cp mytree.contree tree_abbr.iqtree     # cp aligned.fasta.treefile tree_abbr.iqtree
# 创建完整名称版本
cp tree_abbr.iqtree tree_fullName.iqtree
# 替换缩写为完整名称
cut -f 1,2 ../../a.preparing_data/source.txt | while read abbr full; do
    sed -i "s/$abbr/$full/g" tree_fullName.iqtree
done
# 复制到上级目录
cp tree*.iqtree ../
"""
# 真实数据处理时，数据量较大时，推荐按如下步骤使用raxmlHPC-HYBRID-AVX进行并行化计算
# export PKG_CONFIG_PATH=/opt/sysoft/mpich-3.3/lib/pkgconfig:$PKG_CONFIG_PATH
# export LD_LIBRARY_PATH=/opt/sysoft/mpich-3.3/lib:$LD_LIBRARY_PATH
# export C_INCLUDE_PATH=/opt/sysoft/mpich-3.3/include:$C_INCLUDE_PATH
# export PATH=/opt/sysoft/mpich-3.3/bin:$PATH
# export LD_PRELOAD=/opt/sysoft/mpich-3.3/lib/libmpi.so
#/opt/biosoft/RAxML-8.2.12/usefulScripts/convertFasta2Phylip.sh ../FastTree/aligned.fasta > aligned.fasta.phy
# mpirun -np 15 /opt/biosoft/RAxML-8.2.12/raxmlHPC-HYBRID-AVX -f a -x 12345 -p 12345 -# 1000 -m GTRGAMMAX -s allSingleCopyOrthologsAlign.Codon.phy -n out_codon -T 8
#cp RAxML_bipartitions.out_codon tree_abbr.RAxML
#cp tree_abbr.RAxML tree_fullName.RAxML
#cut -f 1,2 ../../a.preparing_data/source.txt | while read abbr full; do
    #sed -i "s/$abbr/$full/g" tree_fullName.RAxML
#done
#cp tree* ../
"""

# FigTree画树，并输出树文件信息
java -jar /opt/biosoft/FigTree_v1.4.4/lib/figtree.jar mytree.contree
# parub  Agaricomycetidae(伞菌亚纲); Boletales(牛肝菌目)
# sccit  Agaricomycetidae(伞菌亚纲); Boletales(牛肝菌目)
# laame  Agaricomycetidae(伞菌亚纲); Agaricales(伞菌目)
# plost  Agaricomycetidae(伞菌亚纲); Agaricales(伞菌目)
# phgig  Agaricomycetes incertae sedis; Polyporales(多孔菌目)
# lasul  Agaricomycetes incertae sedis; Polyporales(多孔菌目)
cd ../
"""
# 7. 可能有部分单拷贝同源基因不利于构建系统发育树，将这些基因挑出来去除掉后，有利于构建更准确的物种树
# 此步骤不是必须的，操作有点复杂，对进化树准确性提高不多。但当RAxML树局部区域拓扑结构不正确，进行修改后，没有枝长数据后，可以考虑使用PAML软件的baseml进行枝长计算。
# 使用PAML软件的baseml对各个单拷贝同源基因进行枝长分析，再与标准树进行比较，剔除异常的基因。
mkdir paml_baseml
cd paml_baseml
# 7.1 根据RAxML的结果提取系统发育树的拓扑结构
echo "6 1" > input.trees
echo "(((parub,sccit),(laame,plost)),(phgig,lasul));" >> input.trees
# 7.2 分别对各个单拷贝同源基因的密码子比对结果用codeml进行系统发育分析，得到每个各个同源基因的树信息
mkdir OG_trees

for i in `cat ../orthologGroups.txt`; do
    echo "calculating_branchLength_by_baseml.pl ../orthologGroups_CDS/$i.phy input.trees > OG_trees/$i.tree"
done > command.calculating_branchLength_by_baseml.list

for i in `cat ../orthologGroups.txt`; do
    echo "python3 calculating_branchLength_by_baseml.py ../orthologGroups_CDS/$i.phy input.trees > OG_trees/$i.tree"
done > command.calculating_branchLength_by_baseml.list

ParaFly -c command.calculating_branchLength_by_baseml.list -CPU 8
# 7.3 整合所有单拷贝同源基因进化树。整合原理：先计算每个树的总枝长，利用其中位数对所有单拷贝同源基因树进行标准化，使每个树的总枝长等于该中位数；再对进化树的每个分支取所有基因的中位数作为其枝长。
get_integrated_tree_from_multiple_trees.pl OG_trees/* > standard.tree
# 7.4 分析每个各个同源基因树枝长和标准树的平均偏差百分比：单拷贝同源基因某分枝的偏差百分比 = (绝对值{单拷贝同源基因树某分>枝的枝长 - 标准树中该分枝的枝长} / 标准树中该分枝的枝长) * 100%；然后计算所有分枝偏差百分比的平均值。
for i in `cat ../orthologGroups.txt`; do
    echo "calculating_branchLength_bias_percentage_of_two_trees.pl standard.tree OG_trees/$i.tree > OG_trees/$i.bias"
done > command.calculating_branchLength_bias_percentage_of_two_trees.list
for i in `cat ../orthologGroups.txt`; do
    echo "python3 calculating_branchLength_bias_percentage_of_two_trees.py standard.tree OG_trees/$i.tree > OG_trees/$i.bias"
done > command.calculating_branchLength_bias_percentage_of_two_trees.list

ParaFly -c command.calculating_branchLength_bias_percentage_of_two_trees.list -CPU 8
awk 'FNR==1 {gsub(/%/, "", $0); printf "%s\t%s\n", FILENAME, $0}' OG_trees/*.bias | sed 's|OG_trees/\(.*\)\.bias|\1|' > bias.txt
# 剔除和综合树差异较大的单拷贝同源基因。第一轮按左侧99%置信区间保留；第二轮按左侧95%置信区间保留。
remove_extremum_through_normal_distribution.pl --data_column 4 --confidence_interval 5 bias.txt > keep_bias_99.txt
remove_extremum_through_normal_distribution.pl --data_column 4 --confidence_interval 2 keep_bias_99.txt > keep_bias_95.txt

python3 remove_extremum_through_normal_distribution.py --data_column 4 --confidence_interval 5 bias.txt > keep_bias_99.txt
python3 remove_extremum_through_normal_distribution.py --data_column 4 --confidence_interval 2 keep_bias_99.txt > keep_bias_95.txt
cut -f 1 keep_bias_95.txt > keep_OG.txt
# 7.5 剔除和综合树差异较大的单拷贝同源基因，利用剩下的基因整合出更准确的综合树。
get_integrated_tree_from_multiple_trees.pl --method median `perl -pe 's#^#OG_trees/#; s/\n/.tree /' keep_OG.txt` > tree_abbr.baseml_median
get_integrated_tree_from_multiple_trees.pl --method mean `perl -pe 's#^#OG_trees/#; s/\n/.tree /' keep_OG.txt` > tree_abbr.baseml_mean

python3 get_integrated_tree_from_multiple_trees.py --method median `perl -pe 's#^#OG_trees/#; s/\n/.tree /' keep_OG.txt` > tree_abbr.baseml_median
python3 get_integrated_tree_from_multiple_trees.py --method mean `perl -pe 's#^#OG_trees/#; s/\n/.tree /' keep_OG.txt` > tree_abbr.baseml_mean
cp tree_abbr.baseml_median tree_fullName.baseml_median
cp tree_abbr.baseml_mean tree_fullName.baseml_mean

cut -f 1,2 ../../a.preparing_data/source.txt | perl -p -e 's/\t/\t\"/; s/$/\"/;' | perl -p -e 's#\s+#/#; s#^#perl -p -i -e "s/#; s#\n$#/" tree_fullName.baseml_median\n#;' | perl -p -e 's#/\"#/\\\"#; s#\"/#\\\"/#;' | sh

cut -f 1,2 ../../a.preparing_data/source.txt | while read abbreviation full_name; do
    sed -i "s/$abbreviation/$full_name/g" tree_fullName.baseml_median
done

cut -f 1,2 ../../a.preparing_data/source.txt | perl -p -e 's/\t/\t\"/; s/$/\"/;' | perl -p -e 's#\s+#/#; s#^#perl -p -i -e "s/#; s#\n$#/" tree_fullName.baseml_mean\n#;' | perl -p -e 's#/\"#/\\\"#; s#\"/#\\\"/#;' | sh

cut -f 1,2 ../../a.preparing_data/source.txt | while read abbreviation full_name; do
    sed -i "s/$abbreviation/$full_name/g" tree_fullName.baseml_mean
done

cp tree_* ../
cd ../../
"""


# d. 使用PAML软件的mcmctree进行物种分歧时间计算
mkdir -p ~/working/12.genome_comparison/d.divergence_time
cd ~/working/12.genome_comparison/d.divergence_time
# (1) 准备Newick格式的树文件，根据RAxML的结果提取系统发育树的拓扑结构
echo "6 1" > input.trees
echo "(((laame,plost),(parub,sccit)'>0.76<1.08')'>2.29<2.66',(lasul,phgig));" >> input.trees
# Paxillus rubicundulus <=> Scleroderma citrinum        89MYA 76-108MYA
# Paxillus rubicundulus <=> Laccaria amethystina	246MYA 229-266MYA
# http://www.timetree.org/ 查询分析时间 有化石时间更好
# (2) 准备多序列比对Phylip格式输入文件，可以综合三个位点核酸序列的多序列比对文件
/opt/biosoft/RAxML-8.2.12/usefulScripts/convertFasta2Phylip.sh allSingleCopyOrthologsAlign.Codon.fasta > input.txt
sed -i 's/[[:space:]]\+/  /g' input.txt
# (3) 准备paml mcmctree配置文件
"""
# 削减计算量
sed '
     s/mtCDNApri123/input/
     s/mtCDNApri/input/
     s/<1\.0/<4.0/
     s/^\([[:space:]]*ndata =\) .*/\1 1/
     s/usedata = .*/usedata = 3/
     s/model = .*/model = 7/
     s/alpha = .*/alpha = 0.5/
     s/ncatG = .*/ncatG = 5/
     s/cleandata = .*/cleandata = 0/
     s/burnin = .*/burnin = 800000/
     s/sampfreq = .*/sampfreq = 100/
     s/nsample = .*/nsample = 20000/
 ' /opt/biosoft/paml4.9i/examples/DatingSoftBound/mcmctree.ctl > mcmctree.ctl
"""
# 正常计算量
    sed '
        s/mtCDNApri123/input/
        s/mtCDNApri/input/
        s/<1\.0/<8.0/
        s/^\([[:space:]]*ndata =\) .*/\1 1/
        s/usedata = .*/usedata = 3/
        s/model = .*/model = 7/
        s/alpha = .*/alpha = 0.5/
        s/ncatG = .*/ncatG = 5/
        s/cleandata = .*/cleandata = 0/
        s/burnin = .*/burnin = 4000000/
        s/sampfreq = .*/sampfreq = 100/
        s/nsample = .*/nsample = 100000/
    ' /opt/biosoft/paml4.9i/examples/DatingSoftBound/mcmctree.ctl > mcmctree.ctl
# (4) 运行PAML软件的mcmctree (若数据量较大，则每当程序调用baseml时，按ctrl + c终止，再手动并行化运行baseml)
# 当看到类似Approximate likelihood (version 4.9i, September 2018)
# Running baseml to calculate gradients...
# Branch length optimization ...
mcmctree mcmctree.ctl
cp out.BV in.BV
# (5) 手动并行化运行baseml
#echo "mkdir tmp0001; cd tmp0001; ln -s ../input* ../tmp0001* ./; baseml tmp0001.ctl;
#mkdir tmp0002; cd tmp0002; ln -s ../input* ../tmp0002* ./; baseml tmp0002.ctl;
#mkdir tmp0003; cd tmp0003; ln -s ../input* ../tmp0003* ./; baseml tmp0003.ctl;" > command.baseml.list
#ParaFly -c command.baseml.list -CPU 3
#cat tmp0001/rst2 tmp0002/rst2 tmp0003/rst2 > in.BV
# (6) 使用mcmctree进行approximate likelihood分析
sed -i 's/usedata = .*/usedata = 2    * 0:/' mcmctree.ctl
mkdir run01 run02
cp input.txt input.trees mcmctree.ctl in.BV run01
cp input.txt input.trees mcmctree.ctl in.BV run02
echo 'cd run01; mcmctree mcmctree.ctl &> mcmctree.log
cd run02; mcmctree mcmctree.ctl &> mcmctree.log' > command.mcmctree.list
ParaFly -c command.mcmctree.list -CPU 2
# (7) 比较两次运行的MCMC树，若差异较小，则认可其结果
python3 -c "
import re
import sys
with open('run01/FigTree.tre', 'r') as f:
    for line in f:
        result = re.sub(r'(\d+\.\d+)', 
                       lambda m: str(float(m.group(1)) * 100), 
                       line)
        sys.stdout.write(result)
" > tree01.nex
python3 -c "
import re
import sys
with open('run02/FigTree.tre', 'r') as f:
    for line in f:
        result = re.sub(r'(\d+\.\d+)', 
                       lambda m: str(float(m.group(1)) * 100), 
                       line)
        sys.stdout.write(result)
" > tree02.nex
awk '/UTREE.*=/ {
     sub(/^.*UTREE[[:space:]]*=[[:space:]]*/, "")
     gsub(/\[[^]]*\]/, "")
     sub(/;.*$/, "")
     print
 }' tree01.nex > tree01.txt
awk '/UTREE.*=/ {
     sub(/^.*UTREE[[:space:]]*=[[:space:]]*/, "")
     gsub(/\[[^]]*\]/, "")
     sub(/;.*$/, "")
     print
 }' tree02.nex > tree02.txt
python3 calculating_branchLength_bias_percentage_of_two_trees.py --no_normalization_of_total_branch_length tree01.txt tree02.txt > bias_of_2runs.txt
python3 -c "
import re
with open('run01/FigTree.tre', 'r') as infile, open('tree_abbr.mcmctree', 'w') as outfile:
    for line in infile:
        result = re.sub(r'(\d+\.\d+)', 
                       lambda m: str(float(m.group(1)) * 100), 
                       line)
        outfile.write(result)
"
# (8) 将树信息中的简称换成属名和种名全称
cp tree_abbr.mcmctree tree_fullName.mcmctree
cut -f 1,2 ../a.preparing_data/source.txt | while read abbreviation full_name; do
    sed -i "s/$abbreviation/$full_name/g" tree_fullName.mcmctree
done
sed -e 's/\[[^]]*\]//g' -e 's/{[^}]*}//g' tree_fullName.mcmctree > tree_fullName.clean.mcmctree
java -jar /opt/biosoft/FigTree_v1.4.4/lib/figtree.jar tree_fullName.mcmctree



# e.CAFE进行基因家族扩张分析
mkdir -p ~/working/12.genome_comparison/e.cafe
cd ~/working/12.genome_comparison/e.cafe
# 根据 orthomcl 结果得到基因家族的数量信息
python3 orthomcl_extract_ortholog_seqs.py --out_directory orthologGroups_CDS --out_tab_for_CAFE orthomcl2cafe.tab --species_ratio 0.4 --single_copy_species_ratio 0.0 --copy_num 1000 --max_seq_length 100000 ../b.OrthoFinder/groups.txt ../b.OrthoFinder/compliantCDS
# 提取至少在3个species中存在该 gene family 的OGs 。
# tree后要使用上一步的分歧树文件
echo '#!/opt/biosoft/CAFE-4.2.1/bin/cafe
version
date

load -i orthomcl2cafe.tab -t 8 -p 0.01
tree (((laame:185.931,plost:185.931):55.4361,(parub:102.5601,sccit:102.5601):138.807):23.4352,(lasul:208.025,phgig:208.025):56.7774);

lambda -s
report out' > cafe_command
/opt/biosoft/CAFE-4.2.1/bin/caferror.py -i cafe_command -e 0.1
parsing_cafe_out.pl caferror_1/cafe_final_report.cafe
cd ../                   


# f. 使用PAML软件的codeml进行正选择基因分析
mkdir -p ~/working/12.genome_comparison/f.PSG_analysis
cd ~/working/12.genome_comparison/f.PSG_analysis
# (1) 准备同源基因的密码子比对结果Phylip格式文件及其sub tree文件
# 选取至少在4个物种中出现的同源基因
python3 orthomcl_extract_ortholog_seqs.py --out_directory orthologGroups_CDS --species_ratio 0.6 --single_copy_species_ratio 0.0 --copy_num 1000 --max_seq_length 100000 ../b.OrthoFinder/groups.txt ../b.OrthoFinder/compliantCDS
python3 orthomcl_extract_ortholog_seqs.py --out_directory orthologGroups_Protein --species_ratio 0.6 --single_copy_species_ratio 0.0 --copy_num 1000 --max_seq_length 100000 --compliantFasta_dir_for_calculating_seq_length ../b.OrthoFinder/compliantCDS/ ../b.OrthoFinder/groups.txt ../b.OrthoFinder/compliantProtein/
for file in orthologGroups_Protein/*.fasta; do
    sed -i 's/\*/X/g' "$file"
done
ls orthologGroups_Protein/*.fasta | xargs -I {} basename {} .fasta > orthologGroups.txt
# 对同源基因的蛋白序列进行多序列比对
for i in `cat orthologGroups.txt`; do 
    echo "/opt/biosoft/mafft/bin/linsi orthologGroups_Protein/$i.fasta > orthologGroups_Protein/$i.fasta.align"
done > command.mafft.list
#ParaFly -c command.mafft.list -CPU 8
for i in `cat orthologGroups.txt`
do
    echo "python3 protein_alignment_cds_alignemnt.py orthologGroups_Protein/$i.fasta.align orthologGroups_CDS/$i.fasta > orthologGroups_CDS/$i.fasta.align"
done > command.protein_alignment_cds_alignemnt.list
ParaFly -c command.protein_alignment_cds_alignemnt.list -CPU 8
sed -i 's/^\(>[[:alnum:]_]\+\).*/\1/' orthologGroups_CDS/*.fasta.align
# 将多序列比对结果转换为Phylip格式
for i in $(cat orthologGroups.txt); do
    sed 's/^\(>[^[:space:]]*\).*/\1/; s/ //g' "orthologGroups_CDS/$i.fasta.align" > "orthologGroups_CDS/$i.fasta.align.fasta"
done
for i in `cat orthologGroups.txt`; do
    echo "/opt/biosoft/RAxML-8.2.12/usefulScripts/convertFasta2Phylip.sh orthologGroups_CDS/$i.fasta.align.fasta > orthologGroups_CDS/$i.phy"
done > command.convertFasta2Phylip.list
ParaFly -c command.convertFasta2Phylip.list -CPU 8
rm -rf orthologGroups_CDS/*.fasta*
# (2) 通过对同源基因序列之间两两计算dn/ds方法，筛选候选的正选择基因
mkdir dnds_yn00
for i in `cat orthologGroups.txt`; do
    echo "~/rmpl/calculating_omega_by_yn00.pl --omega_for_PSG 1.0 --input_tree tree.txt orthologGroups_CDS/$i.phy > dnds_yn00/$i.txt 2> dnds_yn00/$i.stats"
done > command.calculating_omega_by_yn00.list
parallel -j 8 < command.calculating_omega_by_yn00.list
rename PSGyes PSGyes.dnds_yn00 orthologGroups_CDS/*.phy.PSGyes
ls orthologGroups_CDS/*.phy.PSGyes.dnds_yn00 2>/dev/null | sed 's/.*\///; s/\.phy\.PSGyes\.dnds_yn00$//' > PSG_yn00.list
# 使用ML方法计算dn/ds 
mkdir dnds_ML
for i in `cat orthologGroups.txt`; do
    echo "python3 ~/rmpl/calculating_omega_by_codeml.py --omega_for_PSG 1.0 orthologGroups_CDS/$i.phy tree.txt > dnds_ML/$i.txt 2> dnds_ML/$i.stats"
done > command.calculating_omega_by_ML.list
parallel -j 8 < command.calculating_omega_by_ML.list
rename PSGyes PSGyes.dnds_ML orthologGroups_CDS/*.phy.PSGyes
basename -a orthologGroups_CDS/*.phy.PSGyes.dnds_ML 2>/dev/null | grep -o 'OG[0-9]*' > PSG_ML.list
cat PSG_yn00.list PSG_ML.list | sort | uniq > candidate_PSG.list
# rm -rf */dnds_* dnds_ML dnds_yn00
# (3) 使用branch-site model对候选基因进行正选择分析
# 确定待分析的目标分枝
grep -o '\w*' tree.txt | sed '/^$/d' | while read word; do echo "${word}:${word}"; done > branches.txt
echo "Agaricales:laame,plost
Boletales:parub,sccit
Polyporales:lasul,phgig" >> branches.txt
# 使用branch-site model对目标分枝上的候选基因进行正选择分析
for x in `cat branches.txt`
 do
     y=$x
    y=${y/*:/}
     x=${x/:*/}
     y=${y/*:/}
     mkdir -p BS_$x/
     for i in `cat candidate_PSG.list`; do
         echo "paml_branch-site_model_analysis.pl --target_branch_species $y orthologGroups_CDS/$i.phy tree.txt BS_$x/$i > BS_$x/$i.p"
     done
 done > command.paml_branch-site_model.list
parallel -j 8 < command.paml_branch-site_model.list
# 统计各分枝的正选择基因信息
while read line; do
    x="${line%:*}" && y="${line#*:}" && cd "BS_$x" 2>/dev/null && for p in *.p; do
        [ -f "$p" ] && og="${p%.p}" && result=$(awk -F'\t' '$1 <= 0.05 || $2 == "BEB_Significance_YES" {print $1"\t"$2; exit}' "$p" 2>/dev/null) && \
        [[ -n "$result" ]] && echo -e "$x\t$og\t$result"
    done; cd ..; 
done < branches.txt | grep -v NULL > results.PSG.branches
awk '{count[$1]++} END {for (key in count) print key "\t" count[key]}' results.PSG.branches > results.PSG.branches.stats


# g.使用MCScanX进行共线性区块分析
mkdir -p ~/working/12.genome_comparison/g.MCScanX
cd ~/working/12.genome_comparison/g.MCScanX
# 准备2个物种基因组的蛋白质序列文件和GFF文件
ln -s ../a.preparing_data/laame.geneModels.gff3 ./
ln -s ../a.preparing_data/laame.protein.fasta ./
ln -s ../a.preparing_data/laame.genome.fasta ./
ln -s ../a.preparing_data/plost.geneModels.gff3 ./
ln -s ../a.preparing_data/plost.protein.fasta ./
ln -s ../a.preparing_data/plost.genome.fasta ./
cat laame.protein.fasta plost.protein.fasta > all.fasta
sed -i 's/\*$//; s/\*/X/g' all.fasta
diamond makedb --in all.fasta --db all
diamond blastp --db all --query all.fasta --out diamond.out --outfmt 5 --sensitive --max-target-seqs 100 --evalue 1e-5 --id 10 --tmpdir /dev/shm --threads 16
python3 ~/rmpl/parsing_blast_result.py --no-header --max-hit-num 100 --evalue 1e-6 --identity 0.5 --suject-coverage 0.5 --query-coverage 0.5 diamond.out > data/input.blast
awk '$3 == "gene" && /ID=/ {
    match($0, /ID=([^;\t]+)/, arr)
    if (arr[1] != "") {
        print $1 "\t" arr[1] "\t" $4 "\t" $5
    }
}' plost.geneModels.gff3 laame.geneModels.gff3 > data/input.gff
MCScanX data/input
grep -v -P "plost.*plost" data/input.collinearity | grep -P "plost" > data/input.collinearity_interspecific
python3 mcscanx_stats_blocks.py data/input.collinearity_interspecific > data/input.collinearity_interspecific.stats
grep -P "plost.*plost" data/input.collinearity > data/input.collinearity_intraspecific
python3 mcscanx_stats_blocks.py data/input.collinearity_intraspecific > data/input.collinearity_intraspecific.stats
circos_from_MCScanX_out.pl --out-ref-WGD out_WGD --ref-gff3 plost.geneModels.gff3 --ref-fasta plost.genome.fasta --query-gff3 laame.geneModels.gff3 --query-fasta laame.genome.fasta --ref-label PO --query-label LA --min-block-size 5 data/input.collinearity
cd out
/opt/biosoft/circos-0.69-6/bin/circos -conf circos.conf
cd ../out_WGD
/opt/biosoft/circos-0.69-6/bin/circos -conf circos.conf
cd ..


# h. 使用Mummer对两个基因组进行比较
mkdir -p ~/working/12.genome_comparison/h.Mummer
~/working/12.genome_comparison/h.Mummer
cp /home/train/00.incipient_data/data_for_genome_assembling/assemblies_of_Malassezia_sympodialis/Malassezia_sympodialis.genome_V01.fasta ./
cp /home/train/00.incipient_data/data_for_genome_assembling/assemblies_of_Malassezia_sympodialis/idba.fasta ./
python3 ~/rmpl/para_nucmer.py --CPU 8 Malassezia_sympodialis.genome_V01.fasta idba.fasta > out.delta
/opt/biosoft/mummer-4.0.0beta2/bin/nucmer -c 200 -g 200 -p out Malassezia_sympodialis.genome_V01.fasta idba.fasta
/opt/biosoft/mummer-4.0.0beta2/bin/delta-filter -i 95 -r -q out.delta > out.rq.delta
/opt/biosoft/mummer-4.0.0beta2/bin/show-coords -c -d -l -I 95 -L 10000 -r out.rq.delta > out.show
/opt/biosoft/mummer-4.0.0beta2/bin/mummerplot -f -l -p out -s large -t png out.delta
gnuplot out.gp















